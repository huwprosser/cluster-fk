import cv2
import numpy as np
from deepface import DeepFace
from sklearn.cluster import DBSCAN
from imutils import build_montages
from tensorflow.keras.models import Model
from tensorflow.keras.applications.vgg16 import VGG16
from tensorflow.keras.preprocessing.image import load_img
from tensorflow.keras.applications.vgg16 import preprocess_input

# This is quite slow as it takes a while to generate encodings for each sample,
# ideally you would do this on-the-fly and only compare each sample as it is seen in real time.

# Utils help evaluate the results
class Utils:
    def __init__(self):
        pass

    def plot(self, data):
        pass

    def showClusters(self, clusters, clt, data):
        for labelID in clusters:
            idxs = np.where(clt.labels_ == labelID)[0]
            idxs = np.random.choice(idxs, size=min(25, len(idxs)), replace=False)
            faces = []

            for i in idxs:
                face = cv2.imread(data[i]["imagePath"])
                face = cv2.resize(face, (96, 96))
                faces.append(face)

                # create a montage using 96x96 "tiles" with 5 rows and 5 columns
            montage = build_montages(faces, (96, 96), (5, 5))[0]

            # show the output montage
            title = "Cluster ID #{} (press any key to continue)".format(labelID)
            title = "Unknown Cluster" if labelID == -1 else title
            cv2.imshow(title, montage)
            cv2.waitKey(0)

# Object clustering can be done using the encoding layer of an object classifier.
class ObjectClusterBuilder:
    def __init__(
        self, sensitivity=65,
    ):
        self.sensitivity = sensitivity
        self.model = VGG16()
        self.model = Model(
            inputs=self.model.inputs, outputs=self.model.layers[-2].output
        )

    def extract_features(self, file, model):
        # load the image as a 224x224 array
        img = load_img(file, target_size=(224, 224))
        # convert from 'PIL.Image.Image' to numpy array
        img = np.array(img)
        # reshape the data for the model reshape(num_of_samples, dim 1, dim 2, channels)
        reshaped_img = img.reshape(1, 224, 224, 3)
        # prepare image for model
        imgx = preprocess_input(reshaped_img)
        # get the feature vector
        features = model.predict(imgx, use_multiprocessing=True)
        return features

    def build_cluster(self, encodings):
        clt = DBSCAN(eps=self.sensitivity, metric="euclidean", min_samples=1)
        clt.fit(encodings)
        labelIDs = np.unique(clt.labels_)
        labels = len(np.where(labelIDs > -1)[0])
        return labelIDs, labels, clt

    def cluster(self, image_paths):
        data = []
        for path in image_paths:
            features = self.extract_features(path, self.model)
            features = np.reshape(features, (4096,))
            data.append({"encoding": features, "imagePath": path})

        data = np.array(data)
        encodings = [d["encoding"] for d in data]
        labelIDs, labels, clt = self.build_cluster(encodings)

        return labelIDs, labels, data, clt

# Face clustering can be done using face embeddings generated by any face encoding lib
class FaceClusterBuilder:
    def __init__(self, sensitivity=12):
        self.sensitivity = sensitivity

    def extract_face_features(self, file):
        embedding = DeepFace.represent(img_path=file, model_name="Facenet")
        return embedding

    def build_cluster(self, encodings):
        clt = DBSCAN(eps=self.sensitivity, metric="euclidean", min_samples=1)
        clt.fit(encodings)
        labelIDs = np.unique(clt.labels_)
        labels = len(np.where(labelIDs > -1)[0])
        return labelIDs, labels, clt

    def cluster(self, image_paths):
        data = []
        for path in image_paths:
            features = self.extract_face_features(path)
            data.append({"encoding": features, "imagePath": path})

        data = np.array(data)
        encodings = [d["encoding"] for d in data]

        labelIDs, labels, clt = self.build_cluster(encodings)

        return labelIDs, labels, data, clt
